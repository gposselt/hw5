*** File /usr/include/c++/9/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2019 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
                    bad_alloc() throw() { }
                
                #if __cplusplus >= 201103L
                    bad_alloc(const bad_alloc&) = default;
                    bad_alloc& operator=(const bad_alloc&) = default;
                #endif
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                #if __cplusplus >= 201103L
                  class bad_array_new_length : public bad_alloc
                  {
                  public:
                    bad_array_new_length() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_array_new_length() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                #endif
                
                #if __cpp_aligned_new
                  enum class align_val_t: size_t {};
                #endif
                
                  struct nothrow_t
                  {
                #if __cplusplus >= 201103L
                    explicit nothrow_t() = default;
                #endif
                  };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                
                #if __cplusplus >= 201103L
                  /// Return the current new handler.
                  new_handler get_new_handler() noexcept;
                #endif
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #endif
                _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __malloc__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_aligned_new
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
                void operator delete(void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete(void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
                void operator delete[](void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #endif // __cpp_sized_deallocation
                #endif // __cpp_aligned_new
                
                // Default placement versions of operator new.
                _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
          42 -> { return __p; }
                _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #if __cplusplus >= 201703L
                #ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
                namespace std
                {
                #define __cpp_lib_launder 201606
                  /// Pointer optimization barrier [ptr.launder]
                  template<typename _Tp>
                    [[nodiscard]] constexpr _Tp*
                    launder(_Tp* __p) noexcept
                    { return __builtin_launder(__p); }
                
                  // The program is ill-formed if T is a function type or
                  // (possibly cv-qualified) void.
                
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                
                  void launder(void*) = delete;
                  void launder(const void*) = delete;
                  void launder(volatile void*) = delete;
                  void launder(const volatile void*) = delete;
                }
                #endif // _GLIBCXX_HAVE_BUILTIN_LAUNDER
                #endif // C++17
                
                #if __cplusplus > 201703L
                namespace std
                {
                  struct destroying_delete_t
                  {
                    explicit destroying_delete_t() = default;
                  };
                  inline constexpr destroying_delete_t destroying_delete{};
                }
                // Only define the feature test macro if the compiler supports the feature:
                #if __cpp_impl_destroying_delete
                # define __cpp_lib_destroying_delete 201806L
                #endif
                #endif // C++20
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      174         42

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       42   Total number of line executions
    21.00   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator_base_funcs.h:
                // Functions used by iterators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_funcs.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility
                 *  functions, such as distance() and advance().
                 */
                
                #ifndef _STL_ITERATOR_BASE_FUNCS_H
                #define _STL_ITERATOR_BASE_FUNCS_H 1
                
                #pragma GCC system_header
                
                #include <bits/concept_check.h>
                #include <debug/assertions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                  // Forward declaration for the overloads of __distance.
                  template <typename> struct _List_iterator;
                  template <typename> struct _List_const_iterator;
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                  template<typename _InputIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
                    __distance(_InputIterator __first, _InputIterator __last,
                               input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      while (__first != __last)
                	{
                	  ++__first;
                	  ++__n;
                	}
                      return __n;
                    }
                
                  template<typename _RandomAccessIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_RandomAccessIterator>::difference_type
           8 ->     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      return __last - __first;
                    }
                
                #if _GLIBCXX_USE_CXX11_ABI
                  // Forward declaration because of the qualified call in distance.
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       input_iterator_tag);
                
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       input_iterator_tag);
                #endif
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __first  An input iterator.
                   *  @param  __last  An input iterator.
                   *  @return  The distance between them.
                   *
                   *  Returns @c n such that __first + n == __last.  This requires
                   *  that @p __last must be reachable from @p __first.  Note that @c
                   *  n may be negative.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
           8 ->     distance(_InputIterator __first, _InputIterator __last)
                    {
                      // concept requirements -- taken care of in __distance
                      return std::__distance(__first, __last,
                			     std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_assert(__n >= 0);
                      while (__n--)
                	++__i;
                    }
                
                  template<typename _BidirectionalIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_BidirectionalIterator& __i, _Distance __n,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      if (__n > 0)
                        while (__n--)
                	  ++__i;
                      else
                        while (__n++)
                	  --__i;
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_RandomAccessIterator& __i, _Distance __n,
                              random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      if (__builtin_constant_p(__n) && __n == 1)
                	++__i;
                      else if (__builtin_constant_p(__n) && __n == -1)
                	--__i;
                      else
                	__i += __n;
                    }
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __i  An input iterator.
                   *  @param  __n  The @a delta by which to change @p __i.
                   *  @return  Nothing.
                   *
                   *  This increments @p i by @p n.  For bidirectional and random access
                   *  iterators, @p __n may be negative, in which case @p __i is decremented.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX17_CONSTEXPR void
                    advance(_InputIterator& __i, _Distance __n)
                    {
                      // concept requirements -- taken care of in __advance
                      typename iterator_traits<_InputIterator>::difference_type __d = __n;
                      std::__advance(__i, __d, std::__iterator_category(__i));
                    }
                
                #if __cplusplus >= 201103L
                
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR _InputIterator
                    next(_InputIterator __x, typename
                	 iterator_traits<_InputIterator>::difference_type __n = 1)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      std::advance(__x, __n);
                      return __x;
                    }
                
                  template<typename _BidirectionalIterator>
                    inline _GLIBCXX17_CONSTEXPR _BidirectionalIterator
                    prev(_BidirectionalIterator __x, typename
                	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      std::advance(__x, -__n);
                      return __x;
                    }
                
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_FUNCS_H */


Top 10 Lines:

     Line      Count

       98          8
      138          8

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       16   Total number of line executions
     8.00   Average executions per line


*** File /usr/include/c++/9/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp;
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __tmp = this->_M_allocate(__n);
                	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  __tmp, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __tmp = _M_allocate_and_copy(__n,
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	    }
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                #if __cplusplus > 201402L
                      typename vector<_Tp, _Alloc>::reference
                #else
                      void
                #endif
           7 ->       vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
                #if __cplusplus > 201402L
                	return back();
                #endif
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == end())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  {
                #if __cplusplus >= 201103L
                	    const auto __pos = begin() + (__position - cbegin());
                	    // __x could be an existing element of this vector, so make a
                	    // copy of it before _M_insert_aux moves elements around.
                	    _Temporary_value __x_copy(this, __x);
                	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	  }
                      else
                #if __cplusplus >= 201103L
                	_M_realloc_insert(begin() + (__position - cbegin()), __x);
                #else
                	_M_realloc_insert(__position, __x);
                #endif
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
                    vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  const size_type __add = __n - size();
                	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					  __add, __val, _M_get_Tp_allocator());
                	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, (void)++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  _M_range_insert(end(), __first, __last,
                			  std::__iterator_category(__first));
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    _S_check_init_len(__len, _M_get_Tp_allocator());
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    const size_type __attribute__((__unused__)) __n = __len - size();
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    auto
                    vector<_Tp, _Alloc>::
                    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
                    {
                      const auto __n = __position - cbegin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == cend())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::move(__v));
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_insert_aux(begin() + __n, std::move(__v));
                      else
                	_M_realloc_insert(begin() + __n, std::move(__v));
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      auto
                      vector<_Tp, _Alloc>::
                      _M_emplace_aux(const_iterator __position, _Args&&... __args)
                      -> iterator
                      {
                	const auto __n = __position - cbegin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  if (__position == cend())
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				       std::forward<_Args>(__args)...);
                	      ++this->_M_impl._M_finish;
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	    }
                	  else
                	    {
                	      // We need to construct a temporary because something in __args...
                	      // could alias one of the elements of the container and so we
                	      // need to use it before _M_insert_aux moves elements around.
                	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
                	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
                	    }
                	else
                	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
                
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _Arg>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Arg&& __arg)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish - 1)));
                      ++this->_M_impl._M_finish;
                      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                #if __cplusplus < 201103L
                      _Tp __x_copy = __x;
                #endif
                      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                			      this->_M_impl._M_finish - 2,
                			      this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                      *__position = __x_copy;
                #else
                      *__position = std::forward<_Arg>(__arg);
                #endif
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
          25 ->       vector<_Tp, _Alloc>::
                      _M_realloc_insert(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_realloc_insert(iterator __position, const _Tp& __x)
                #endif
                    {
                      const size_type __len =
                	_M_check_len(size_type(1), "vector::_M_realloc_insert");
                      pointer __old_start = this->_M_impl._M_start;
                      pointer __old_finish = this->_M_impl._M_finish;
                      const size_type __elems_before = __position - begin();
                      pointer __new_start(this->_M_allocate(__len));
                      pointer __new_finish(__new_start);
                      __try
                	{
                	  // The order of the three operations is dictated by the C++11
                	  // case, where the moves could alter a new element belonging
                	  // to the existing vector.  This is an issue only for callers
                	  // taking the element by lvalue ref (see last bullet of C++11
                	  // [res.on.arguments]).
                	  _Alloc_traits::construct(this->_M_impl,
                				   __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				   std::forward<_Args>(__args)...);
                #else
                				   __x);
                #endif
                	  __new_finish = pointer();
                
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __new_finish = _S_relocate(__old_start, __position.base(),
                					 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish = _S_relocate(__position.base(), __old_finish,
                					 __new_finish, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__old_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), __old_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                	}
                      __catch(...)
                	{
                	  if (!__new_finish)
                	    _Alloc_traits::destroy(this->_M_impl,
                				   __new_start + __elems_before);
                	  else
                	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	  _M_deallocate(__new_start, __len);
                	  __throw_exception_again;
                	}
                #if __cplusplus >= 201103L
                      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
                #endif
                	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      _M_deallocate(__old_start,
                		    this->_M_impl._M_end_of_storage - __old_start);
                      this->_M_impl._M_start = __new_start;
                      this->_M_impl._M_finish = __new_finish;
                      this->_M_impl._M_end_of_storage = __new_start + __len;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                #if __cplusplus < 201103L
                	      value_type __x_copy = __x;
                #else
                	      _Temporary_value __tmp(this, __x);
                	      value_type& __x_copy = __tmp._M_val();
                #endif
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  this->_M_impl._M_finish =
                		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						  __n - __elems_after,
                						  __x_copy,
                						  _M_get_Tp_allocator());
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_realloc_insert above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = pointer();
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  const size_type __size = size();
                	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
                					 - this->_M_impl._M_finish);
                
                	  if (__size > max_size() || __navail > max_size() - __size)
                	    __builtin_unreachable();
                
                	  if (__navail >= __n)
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	      this->_M_impl._M_finish =
                		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                						 __n, _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      pointer __new_start(this->_M_allocate(__len));
                	      if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                		{
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		}
                	      else
                		{
                		  pointer __destroy_from = pointer();
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		      __destroy_from = __new_start + __size;
                		      std::__uninitialized_move_if_noexcept_a(
                			      this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      if (__destroy_from)
                			std::_Destroy(__destroy_from, __destroy_from + __n,
                				      _M_get_Tp_allocator());
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                				_M_get_Tp_allocator());
                		}
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_start + __size + __n;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	if (__pos == end())
                	  {
                	    for (; __first != __last; ++__first)
                	      insert(end(), *__first);
                	  }
                	else if (__first != __last)
                	  {
                	    vector __tmp(__first, __last, _M_get_Tp_allocator());
                	    insert(__pos,
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.begin()),
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.end()));
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_GLIBCXX_ASAN_ANNOTATE_REINIT;
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_pointer __q = this->_M_allocate(__n);
                      iterator __start(std::__addressof(*__q), 0);
                      iterator __finish(_M_copy_aligned(begin(), end(), __start));
                      this->_M_deallocate();
                      this->_M_impl._M_start = __start;
                      this->_M_impl._M_finish = __finish;
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  iterator __finish = std::copy(__position, end(),
                					__i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_pointer __q = this->_M_allocate(__len);
                		iterator __start(std::__addressof(*__q), 0);
                		iterator __i = _M_copy_aligned(begin(), __position, __start);
                		__i = std::copy(__first, __last, __i);
                		iterator __finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = __start;
                		this->_M_impl._M_finish = __finish;
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  *__i++ = __x;
                	  iterator __finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #undef _GLIBCXX_ASAN_ANNOTATE_REINIT
                #undef _GLIBCXX_ASAN_ANNOTATE_GROW
                #undef _GLIBCXX_ASAN_ANNOTATE_GREW
                #undef _GLIBCXX_ASAN_ANNOTATE_SHRINK
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      426         25
      109          7

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       32   Total number of line executions
    16.00   Average executions per line


*** File /usr/include/c++/9/initializer_list:
                // std::initializer_list support -*- C++ -*-
                
                // Copyright (C) 2008-2019 Free Software Foundation, Inc.
                //
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                //
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file initializer_list
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _INITIALIZER_LIST
                #define _INITIALIZER_LIST
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else // C++0x
                
                #pragma GCC visibility push(default)
                
                #include <bits/c++config.h>
                
                namespace std
                {
                  /// initializer_list
                  template<class _E>
                    class initializer_list
                    {
                    public:
                      typedef _E 		value_type;
                      typedef const _E& 	reference;
                      typedef const _E& 	const_reference;
                      typedef size_t 		size_type;
                      typedef const _E* 	iterator;
                      typedef const _E* 	const_iterator;
                
                    private:
                      iterator			_M_array;
                      size_type			_M_len;
                
                      // The compiler can call a private constructor.
                      constexpr initializer_list(const_iterator __a, size_type __l)
                      : _M_array(__a), _M_len(__l) { }
                
                    public:
                      constexpr initializer_list() noexcept
                      : _M_array(0), _M_len(0) { }
                
                      // Number of elements.
                      constexpr size_type
           8 ->       size() const noexcept { return _M_len; }
                
                      // First element.
                      constexpr const_iterator
          16 ->       begin() const noexcept { return _M_array; }
                
                      // One past the last element.
                      constexpr const_iterator
           8 ->       end() const noexcept { return begin() + size(); }
                    };
                
                  /**
                   *  @brief  Return an iterator pointing to the first element of
                   *          the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    begin(initializer_list<_Tp> __ils) noexcept
                    { return __ils.begin(); }
                
                  /**
                   *  @brief  Return an iterator pointing to one past the last element
                   *          of the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    end(initializer_list<_Tp> __ils) noexcept
                    { return __ils.end(); }
                }
                
                #pragma GCC visibility pop
                
                #endif // C++11
                
                #endif // _INITIALIZER_LIST


Top 10 Lines:

     Line      Count

       75         16
       71          8
       79          8

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       32   Total number of line executions
    10.67   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For __void_t, is_convertible
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  ///@{
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  ///@{
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                  ///@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                #if __cplusplus >= 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
                  template<typename _Iterator, typename = __void_t<>>
                    struct __iterator_traits { };
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator,
                			     __void_t<typename _Iterator::iterator_category,
                				      typename _Iterator::value_type,
                				      typename _Iterator::difference_type,
                				      typename _Iterator::pointer,
                				      typename _Iterator::reference>>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                #else
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif
                
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline _GLIBCXX_CONSTEXPR
                    typename iterator_traits<_Iter>::iterator_category
           8 ->     __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  ///@}
                
                #if __cplusplus < 201103L
                  // If _Iterator has a base returns it otherwise _Iterator is returned
                  // untouched
                  template<typename _Iterator, bool _HasBase>
                    struct _Iter_base
                    {
                      typedef _Iterator iterator_type;
                      static iterator_type _S_base(_Iterator __it)
                      { return __it; }
                    };
                
                  template<typename _Iterator>
                    struct _Iter_base<_Iterator, true>
                    {
                      typedef typename _Iterator::iterator_type iterator_type;
                      static iterator_type _S_base(_Iterator __it)
                      { return __it.base(); }
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _InIter>
                    using _RequireInputIter = typename
                      enable_if<is_convertible<typename
                		iterator_traits<_InIter>::iterator_category,
                			       input_iterator_tag>::value>::type;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */
                


Top 10 Lines:

     Line      Count

      205          8

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     8.00   Average executions per line


*** File /usr/include/c++/9/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <bits/move.h>
                # include <bits/alloc_traits.h>
                #else
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                /**
                 * @brief  Uniform interface to C++98 and C++11 allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc, typename = typename _Alloc::value_type>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++11 allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      using __is_custom_pointer
                	= std::__and_<std::is_same<pointer, _Ptr>,
                		      std::__not_<std::is_pointer<_Ptr>>>;
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
                					      std::forward<_Args>(__args)...)))
                      {
                	_Base_type::construct(__a, std::__to_address(__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      destroy(_Alloc& __a, _Ptr __p)
                      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
                      { _Base_type::destroy(__a, std::__to_address(__p)); }
                
           7 ->     static _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
                    static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
                    static constexpr bool _S_always_equal()
                    { return _Base_type::is_always_equal::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    _GLIBCXX_NODISCARD static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
                      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
                    static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
                    static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
                    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

       97          7

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        7   Total number of line executions
     7.00   Average executions per line


*** File /usr/include/c++/9/bits/cpp_type_traits.h:
                // The  -*- C++ -*- type traits classes for internal use in libstdc++
                
                // Copyright (C) 2000-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/cpp_type_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{ext/type_traits}
                 */
                
                // Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
                
                #ifndef _CPP_TYPE_TRAITS_H
                #define _CPP_TYPE_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                //
                // This file provides some compile-time information about various types.
                // These representations were designed, on purpose, to be constant-expressions
                // and not types as found in <bits/type_traits.h>.  In particular, they
                // can be used in control structures and the optimizer hopefully will do
                // the obvious thing.
                //
                // Why integral expressions, and not functions nor types?
                // Firstly, these compile-time entities are used as template-arguments
                // so function return values won't work:  We need compile-time entities.
                // We're left with types and constant  integral expressions.
                // Secondly, from the point of view of ease of use, type-based compile-time
                // information is -not- *that* convenient.  One has to write lots of
                // overloaded functions and to hope that the compiler will select the right
                // one. As a net effect, the overall structure isn't very clear at first
                // glance.
                // Thirdly, partial ordering and overload resolution (of function templates)
                // is highly costly in terms of compiler-resource.  It is a Good Thing to
                // keep these resource consumption as least as possible.
                //
                // See valarray_array.h for a case use.
                //
                // -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
                //
                // Update 2005: types are also provided and <bits/type_traits.h> has been
                // removed.
                //
                
                extern "C++" {
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __true_type { };
                  struct __false_type { };
                
                  template<bool>
                    struct __truth_type
                    { typedef __false_type __type; };
                
                  template<>
                    struct __truth_type<true>
                    { typedef __true_type __type; };
                
                  // N.B. The conversions to bool are needed due to the issue
                  // explained in c++/19404.
                  template<class _Sp, class _Tp>
                    struct __traitor
                    {
                      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
                      typedef typename __truth_type<__value>::__type __type;
                    };
                
                  // Compare for equality of types.
                  template<typename, typename>
                    struct __are_same
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __are_same<_Tp, _Tp>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  // Holds if the template-argument is a void type.
                  template<typename _Tp>
                    struct __is_void
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_void<void>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Integer types
                  //
                  template<typename _Tp>
                    struct __is_integer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Thirteen specializations (yes there are eleven standard integer
                  // types; <em>long long</em> and <em>unsigned long long</em> are
                  // supported as extensions).  Up to four target-specific __int<N>
                  // types are supported as well.
                  template<>
                    struct __is_integer<bool>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                # ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    struct __is_integer<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                # endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_integer<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __is_integer<char16_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char32_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<>
                    struct __is_integer<short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #define __INT_N(TYPE) 			\
                  template<>				\
                    struct __is_integer<TYPE>		\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };					\
                  template<>				\
                    struct __is_integer<unsigned TYPE>	\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };
                
                #ifdef __GLIBCXX_TYPE_INT_N_0
                __INT_N(__GLIBCXX_TYPE_INT_N_0)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_1
                __INT_N(__GLIBCXX_TYPE_INT_N_1)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_2
                __INT_N(__GLIBCXX_TYPE_INT_N_2)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_3
                __INT_N(__GLIBCXX_TYPE_INT_N_3)
                #endif
                
                #undef __INT_N
                
                  //
                  // Floating point types
                  //
                  template<typename _Tp>
                    struct __is_floating
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // three specializations (float, double and 'long double')
                  template<>
                    struct __is_floating<float>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<long double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Pointer types
                  //
                  template<typename _Tp>
                    struct __is_pointer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __is_pointer<_Tp*>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // An arithmetic type is an integer type or a floating point type
                  //
                  template<typename _Tp>
                    struct __is_arithmetic
                    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
                    { };
                
                  //
                  // A scalar type is an arithmetic type or a pointer type
                  // 
                  template<typename _Tp>
                    struct __is_scalar
                    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
                    { };
                
                  //
                  // For use in std::copy and std::find overloads for streambuf iterators.
                  //
                  template<typename _Tp>
                    struct __is_char
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_char<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    struct __is_char<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename _Tp>
                    struct __is_byte
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_byte<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #if __cplusplus >= 201703L
                  enum class byte : unsigned char;
                
                  template<>
                    struct __is_byte<byte>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif // C++17
                
                  //
                  // Move iterator type
                  //
                  template<typename _Tp>
                    struct __is_move_iterator
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the move_iterator wrapper.
                  template<typename _Iterator>
                    inline _Iterator
          42 ->     __miter_base(_Iterator __it)
                    { return __it; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                } // extern "C++"
                
                #endif //_CPP_TYPE_TRAITS_H


Top 10 Lines:

     Line      Count

      428         42

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       42   Total number of line executions
    42.00   Average executions per line


*** File /usr/include/c++/9/bits/move.h:
                // Move, forward and identity for C++11 + swap -*- C++ -*-
                
                // Copyright (C) 2007-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #include <bits/concept_check.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR _Tp*
          70 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    { return __builtin_addressof(__r); }
                
                #if __cplusplus >= 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
          84 ->     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp is an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    constexpr typename std::remove_reference<_Tp>::type&&
          21 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                #if __cplusplus > 201402L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2296. std::addressof should be constexpr
                # define __cpp_lib_addressof_constexpr 201603
                #endif
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    inline _GLIBCXX17_CONSTEXPR _Tp*
                    addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2598. addressof works on temporaries
                  template<typename _Tp>
                    const _Tp* addressof(const _Tp&&) = delete;
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
                			      is_move_constructible<_Tp>,
                			      is_move_assignable<_Tp>>::value>::type
                    swap(_Tp& __a, _Tp& __b)
                    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                	            is_nothrow_move_assignable<_Tp>>::value)
                #else
                    void
                    swap(_Tp& __a, _Tp& __b)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__is_swappable<_Tp>::value>::type
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                    noexcept(__is_nothrow_swappable<_Tp>::value)
                #else
                    void
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                #endif
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       74         84
       47         70
       99         21

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      175   Total number of line executions
    58.33   Average executions per line


*** File /usr/include/c++/9/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                #if __cplusplus > 201402L
                #include <utility>
                #endif
                
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
           1 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, (void)++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
       ##### ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
           1 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::copy
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
                	  "result type must be constructible from value type of input range");
                
                      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
                      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
                      // Trivial types can have deleted assignment, so using std::copy
                      // would be ill-formed. Require assignability before using std::copy:
                      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { return std::fill_n(__first, __n, __x); }
                    };
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 1339. uninitialized_fill_n should return the end of its range
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, (void)++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
           1 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
       ##### ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { return std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill(__first, __last, _ValueType());
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  return std::fill_n(__first, __n, _ValueType());
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default constructed value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      return __uninitialized_default_n_1<__is_trivial(_ValueType)
                				       && __assignable>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s), constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with n default constructed value_types(s),
                  // constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { return std::__uninitialized_default_n(__first, __n); }
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_1
                    {
                      template<typename _ForwardIterator>
                	static void
                	__uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{ return std::next(__first, __n); }
                    };
                
                  // __uninitialized_default_novalue
                  // Fills [first, last) with std::distance(first, last) default-initialized
                  // value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default_novalue(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_novalue_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default-initialized value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      return __uninitialized_default_novalue_n_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue_n(__first, __n);
                    }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return {__first, __cur};
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline pair<_RandomAccessIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    {
                      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
                      auto __first_res = std::next(__first, __n);
                      return {__first_res, __second_res};
                    }
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			      _ForwardIterator __result)
                    {
                      return
                	std::__uninitialized_copy_n_pair(__first, __n, __result,
                					 std::__iterator_category(__first));
                    }
                
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_raw_memory_algorithms 201606L
                
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_default_construct(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      __uninitialized_default_novalue(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_novalue_n(__first, __count);
                    }
                
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_value_construct(_ForwardIterator __first,
                				  _ForwardIterator __last)
                    {
                      return __uninitialized_default(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_n(__first, __count);
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_move(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      return std::uninitialized_copy
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_ITERATOR(__last), __result);
                    }
                
                  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    uninitialized_move_n(_InputIterator __first, _Size __count,
                			 _ForwardIterator __result)
                    {
                      auto __res = std::__uninitialized_copy_n_pair
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 __count, __result);
                      return {__res.first.base(), __res.second};
                    }
                #endif // C++17
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Up, typename _Allocator>
                    inline void
           7 ->     __relocate_object_a(_Tp* __dest, _Up* __orig, _Allocator& __alloc)
                    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
                			 __dest, std::move(*__orig)))
                	     && noexcept(std::allocator_traits<_Allocator>::destroy(
                			    __alloc, std::__addressof(*__orig))))
                    {
                      typedef std::allocator_traits<_Allocator> __traits;
                      __traits::construct(__alloc, __dest, std::move(*__orig));
                      __traits::destroy(__alloc, std::__addressof(*__orig));
                    }
                
                  // This class may be specialized for specific types.
                  // Also known as is_trivially_relocatable.
                  template<typename _Tp, typename = void>
                    struct __is_bitwise_relocatable
                    : is_trivial<_Tp> { };
                
                  template <typename _Tp, typename _Up>
                    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
          42 ->     __relocate_a_1(_Tp* __first, _Tp* __last,
                		   _Tp* __result, allocator<_Up>&) noexcept
                    {
                      ptrdiff_t __count = __last - __first;
                      if (__count > 0)
                	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
                      return __result + __count;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
           8 ->     __relocate_a_1(_InputIterator __first, _InputIterator __last,
                		   _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
                					       std::addressof(*__first),
                					       __alloc)))
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                      static_assert(std::is_same<_ValueType, _ValueType2>::value,
                	  "relocation is only possible for values of the same type");
                      _ForwardIterator __cur = __result;
                      for (; __first != __last; ++__first, (void)++__cur)
                	std::__relocate_object_a(std::__addressof(*__cur),
                				 std::__addressof(*__first), __alloc);
                      return __cur;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
          50 ->     __relocate_a(_InputIterator __first, _InputIterator __last,
                		 _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
                				     std::__niter_base(__last),
                				     std::__niter_base(__result), __alloc)))
                    {
                      return __relocate_a_1(std::__niter_base(__first),
                			    std::__niter_base(__last),
                			    std::__niter_base(__result), __alloc);
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      958         50
      924         42
      936          8
      905          7
       76          1
      115          1
      305          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

      110   Total number of line executions
    12.22   Average executions per line


*** File /usr/include/c++/9/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <ext/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _T1, typename... _Args>
                    inline void
           7 ->     _Construct(_T1* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  template<typename _T1>
                    inline void
                    _Construct_novalue(_T1* __p)
                    { ::new(static_cast<void*>(__p)) _T1; }
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    inline void
          14 ->     _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                        static void
           2 ->         __destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
          14 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    inline void
          16 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  template<bool>
                    struct _Destroy_n_aux
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  for (; __count > 0; (void)++__first, --__count)
                	    std::_Destroy(std::__addressof(*__first));
                	  return __first;
                	}
                    };
                
                  template<>
                    struct _Destroy_n_aux<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  std::advance(__first, __count);
                	  return __first;
                	}
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    _Destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy_n(__first, __count);
                    }
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                      for (; __first != __last; ++__first)
                	__traits::destroy(__alloc, std::__addressof(*__first));
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
          16 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                #if __cplusplus > 201402L
                  template <typename _Tp>
                    inline void
                    destroy_at(_Tp* __location)
                    {
                      std::_Destroy(__location);
                    }
                
                  template <typename _ForwardIterator>
                    inline void
                    destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      std::_Destroy(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      return std::_Destroy_n(__first, __count);
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      127         16
      203         16
       97         14
      117         14
       74          7
      105          2

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

       69   Total number of line executions
    11.50   Average executions per line


*** File /usr/include/c++/9/bits/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/alloc_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOC_TRAITS_H
                #define _ALLOC_TRAITS_H 1
                
                #if __cplusplus >= 201103L
                
                #include <bits/memoryfwd.h>
                #include <bits/ptr_traits.h>
                #include <ext/numeric_traits.h>
                
                #define __cpp_lib_allocator_traits_is_always_equal 201411
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __allocator_traits_base
                  {
                    template<typename _Tp, typename _Up, typename = void>
                      struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                    template<typename _Tp, typename _Up>
                      struct __rebind<_Tp, _Up,
                		      __void_t<typename _Tp::template rebind<_Up>::other>>
                      { using type = typename _Tp::template rebind<_Up>::other; };
                
                  protected:
                    template<typename _Tp>
                      using __pointer = typename _Tp::pointer;
                    template<typename _Tp>
                      using __c_pointer = typename _Tp::const_pointer;
                    template<typename _Tp>
                      using __v_pointer = typename _Tp::void_pointer;
                    template<typename _Tp>
                      using __cv_pointer = typename _Tp::const_void_pointer;
                    template<typename _Tp>
                      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
                    template<typename _Tp>
                      using __pocma = typename _Tp::propagate_on_container_move_assignment;
                    template<typename _Tp>
                      using __pocs = typename _Tp::propagate_on_container_swap;
                    template<typename _Tp>
                      using __equal = typename _Tp::is_always_equal;
                  };
                
                  template<typename _Alloc, typename _Up>
                    using __alloc_rebind
                      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
                
                  /**
                   * @brief  Uniform interface to all allocator types.
                   * @ingroup allocators
                  */
                  template<typename _Alloc>
                    struct allocator_traits : __allocator_traits_base
                    {
                      /// The allocator type
                      typedef _Alloc allocator_type;
                      /// The allocated type
                      typedef typename _Alloc::value_type value_type;
                
                      /**
                       * @brief   The allocator's pointer type.
                       *
                       * @c Alloc::pointer if that type exists, otherwise @c value_type*
                      */
                      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
                
                    private:
                      // Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>
                      template<template<typename> class _Func, typename _Tp, typename = void>
                	struct _Ptr
                	{
                	  using type = typename pointer_traits<pointer>::template rebind<_Tp>;
                	};
                
                      template<template<typename> class _Func, typename _Tp>
                	struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
                	{
                	  using type = _Func<_Alloc>;
                	};
                
                      // Select _A2::difference_type or pointer_traits<_Ptr>::difference_type
                      template<typename _A2, typename _PtrT, typename = void>
                	struct _Diff
                	{ using type = typename pointer_traits<_PtrT>::difference_type; };
                
                      template<typename _A2, typename _PtrT>
                	struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
                	{ using type = typename _A2::difference_type; };
                
                      // Select _A2::size_type or make_unsigned<_DiffT>::type
                      template<typename _A2, typename _DiffT, typename = void>
                	struct _Size : make_unsigned<_DiffT> { };
                
                      template<typename _A2, typename _DiffT>
                	struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
                	{ using type = typename _A2::size_type; };
                
                    public:
                      /**
                       * @brief   The allocator's const pointer type.
                       *
                       * @c Alloc::const_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
                      */
                      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
                
                      /**
                       * @brief   The allocator's void pointer type.
                       *
                       * @c Alloc::void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<void> </tt>
                      */
                      using void_pointer = typename _Ptr<__v_pointer, void>::type;
                
                      /**
                       * @brief   The allocator's const void pointer type.
                       *
                       * @c Alloc::const_void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
                      */
                      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
                
                      /**
                       * @brief   The allocator's difference type
                       *
                       * @c Alloc::difference_type if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::difference_type </tt>
                      */
                      using difference_type = typename _Diff<_Alloc, pointer>::type;
                
                      /**
                       * @brief   The allocator's size type
                       *
                       * @c Alloc::size_type if that type exists, otherwise
                       * <tt> make_unsigned<difference_type>::type </tt>
                      */
                      using size_type = typename _Size<_Alloc, difference_type>::type;
                
                      /**
                       * @brief   How the allocator is propagated on copy assignment
                       *
                       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_copy_assignment
                	= __detected_or_t<false_type, __pocca, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on move assignment
                       *
                       * @c Alloc::propagate_on_container_move_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_move_assignment
                	= __detected_or_t<false_type, __pocma, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on swap
                       *
                       * @c Alloc::propagate_on_container_swap if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_swap
                	= __detected_or_t<false_type, __pocs, _Alloc>;
                
                      /**
                       * @brief   Whether all instances of the allocator type compare equal.
                       *
                       * @c Alloc::is_always_equal if that type exists,
                       * otherwise @c is_empty<Alloc>::type
                      */
                      using is_always_equal
                	= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
                
                      template<typename _Tp>
                	using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
                      template<typename _Tp>
                	using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                
                    private:
                      template<typename _Alloc2>
                	static auto
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
                	-> decltype(__a.allocate(__n, __hint))
                	{ return __a.allocate(__n, __hint); }
                
                      template<typename _Alloc2>
                	static pointer
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
                	{ return __a.allocate(__n); }
                
                      template<typename _Tp, typename... _Args>
                	struct __construct_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->construct(
                		  std::declval<_Tp*>(), std::declval<_Args>()...))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp, typename... _Args>
                	using __has_construct
                	  = typename __construct_helper<_Tp, _Args...>::type;
                
                      template<typename _Tp, typename... _Args>
                	static _Require<__has_construct<_Tp, _Args...>>
                	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      template<typename _Tp, typename... _Args>
                	static
                	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                			       is_constructible<_Tp, _Args...>>>
                	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
                	{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }
                
                      template<typename _Alloc2, typename _Tp>
                	static auto
                	_S_destroy(_Alloc2& __a, _Tp* __p, int)
                	noexcept(noexcept(__a.destroy(__p)))
                	-> decltype(__a.destroy(__p))
                	{ __a.destroy(__p); }
                
                      template<typename _Alloc2, typename _Tp>
                	static void
                	_S_destroy(_Alloc2&, _Tp* __p, ...)
                	noexcept(std::is_nothrow_destructible<_Tp>::value)
                	{ __p->~_Tp(); }
                
                      template<typename _Alloc2>
                	static auto
                	_S_max_size(_Alloc2& __a, int)
                	-> decltype(__a.max_size())
                	{ return __a.max_size(); }
                
                      template<typename _Alloc2>
                	static size_type
                	_S_max_size(_Alloc2&, ...)
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2466. allocator_traits::max_size() default behavior is incorrect
                	  return __gnu_cxx::__numeric_traits<size_type>::__max
                	    / sizeof(value_type);
                	}
                
                      template<typename _Alloc2>
                	static auto
                	_S_select(_Alloc2& __a, int)
                	-> decltype(__a.select_on_container_copy_construction())
                	{ return __a.select_on_container_copy_construction(); }
                
                      template<typename _Alloc2>
                	static _Alloc2
                	_S_select(_Alloc2& __a, ...)
                	{ return __a; }
                
                    public:
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
                       *  well-formed, otherwise returns @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
                      { return _S_allocate(__a, __n, __hint, 0); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void
                      deallocate(_Alloc& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Tp`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                       *  if that expression is well-formed, otherwise uses placement-new
                       *  to construct an object of type @a _Tp at location @a __p from the
                       *  arguments @a __args...
                      */
                      template<typename _Tp, typename... _Args>
                	static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(_S_construct(__a, __p,
                				       std::forward<_Args>(__args)...)))
                	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
                	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p) if that expression is well-formed,
                       *  otherwise calls @c __p->~_Tp()
                      */
                      template<typename _Tp>
                	static void destroy(_Alloc& __a, _Tp* __p)
                	noexcept(noexcept(_S_destroy(__a, __p, 0)))
                	{ _S_destroy(__a, __p, 0); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
                       *
                       *  Returns @c __a.max_size() if that expression is well-formed,
                       *  otherwise returns @c numeric_limits<size_type>::max()
                      */
                      static size_type max_size(const _Alloc& __a) noexcept
                      { return _S_max_size(__a, 0); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
                       *
                       *  Returns @c __rhs.select_on_container_copy_construction() if that
                       *  expression is well-formed, otherwise returns @a __rhs
                      */
                      static _Alloc
                      select_on_container_copy_construction(const _Alloc& __rhs)
                      { return _S_select(__rhs, 0); }
                    };
                
                  /// Partial specialization for std::allocator.
                  template<typename _Tp>
                    struct allocator_traits<allocator<_Tp>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<_Tp>;
                      /// The allocated type
                      using value_type = _Tp;
                
                      /// The allocator's pointer type.
                      using pointer = _Tp*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const _Tp*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      /// Whether all instances of the allocator type compare equal.
                      using is_always_equal = true_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
          40 ->       allocate(allocator_type& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt>
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
                      { return __a.allocate(__n, __hint); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void
          40 ->       deallocate(allocator_type& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                      */
                      template<typename _Up, typename... _Args>
                	static void
          35 -> 	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p).
                      */
                      template<typename _Up>
                	static void
           7 -> 	destroy(allocator_type& __a, _Up* __p)
                	noexcept(noexcept(__a.destroy(__p)))
                	{ __a.destroy(__p); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size()
                      */
                      static size_type
          51 ->       max_size(const allocator_type& __a) noexcept
                      { return __a.max_size(); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs
                      */
                      static allocator_type
           7 ->       select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
                    { __one = __two; }
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
                      __do_alloc_on_copy(__one, __two, __pocca());
                    }
                
                  template<typename _Alloc>
                    inline _Alloc __alloc_on_copy(const _Alloc& __a)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      return __traits::select_on_container_copy_construction(__a);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
                    { __one = std::move(__two); }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_move_assignment __pocma;
                      __do_alloc_on_move(__one, __two, __pocma());
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
                    {
                      using std::swap;
                      swap(__one, __two);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_swap __pocs;
                      __do_alloc_on_swap(__one, __two, __pocs());
                    }
                
                  template<typename _Alloc, typename _Tp,
                	   typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
                	   typename = void>
                    struct __is_alloc_insertable_impl
                    : false_type
                    { };
                
                  template<typename _Alloc, typename _Tp, typename _ValueT>
                    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
                      __void_t<decltype(allocator_traits<_Alloc>::construct(
                		   std::declval<_Alloc&>(), std::declval<_ValueT*>(),
                		   std::declval<_Tp>()))>>
                    : true_type
                    { };
                
                  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_copy_insertable
                    : __is_alloc_insertable_impl<_Alloc,
                				 typename _Alloc::value_type const&>::type
                    { };
                
                  // std::allocator<_Tp> just requires CopyConstructible
                  template<typename _Tp>
                    struct __is_copy_insertable<allocator<_Tp>>
                    : is_copy_constructible<_Tp>
                    { };
                
                  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_move_insertable
                    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
                    { };
                
                  // std::allocator<_Tp> just requires MoveConstructible
                  template<typename _Tp>
                    struct __is_move_insertable<allocator<_Tp>>
                    : is_move_constructible<_Tp>
                    { };
                
                  // Trait to detect Allocator-like types.
                  template<typename _Alloc, typename = void>
                    struct __is_allocator : false_type { };
                
                  template<typename _Alloc>
                    struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type,
                	       decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
                    : true_type { };
                
                  template<typename _Alloc>
                    using _RequireAllocator
                      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
                
                  template<typename _Alloc>
                    using _RequireNotAllocator
                      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                #endif // C++11
                #endif // _ALLOC_TRAITS_H


Top 10 Lines:

     Line      Count

      504         51
      442         40
      468         40
      481         35
      494          7
      513          7

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      180   Total number of line executions
    30.00   Average executions per line


*** File /usr/include/c++/9/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard.
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef new_allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
                      _GLIBCXX20_CONSTEXPR
          37 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      _GLIBCXX20_CONSTEXPR
          30 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
                	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
          67 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      _GLIBCXX_NODISCARD pointer
          40 ->       allocate(size_type __n, const void* = static_cast<const void*>(0))
                      {
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
                	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
                	  }
                #endif
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
          40 ->       deallocate(pointer __p, size_type)
                      {
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    ::operator delete(__p, std::align_val_t(alignof(_Tp)));
                	    return;
                	  }
                #endif
                	::operator delete(__p);
                      }
                
                      size_type
          91 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      {
                #if __PTRDIFF_MAX__ < __SIZE_MAX__
                	return size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
                #else
                	return size_t(-1) / sizeof(_Tp);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                	void
          35 -> 	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
           7 -> 	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void
                      construct(pointer __p, const _Tp& __val)
                      { ::new((void *)__p) _Tp(__val); }
                
                      void
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                
                      template<typename _Up>
                	friend bool
                	operator==(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return true; }
                
                      template<typename _Up>
                	friend bool
                	operator!=(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return false; }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      132         91
       89         67
      102         40
      119         40
       80         37
      144         35
       83         30
      150          7

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

      347   Total number of line executions
    43.38   Average executions per line


*** File /usr/include/c++/9/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                #include <debug/assertions.h>
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                extern "C" void
                __sanitizer_annotate_contiguous_container(const void*, const void*,
                					  const void*, const void*);
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
                      struct _Vector_impl_data
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
           9 -> 	_Vector_impl_data() _GLIBCXX_NOEXCEPT
                	: _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
           7 -> 	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
                	: _M_start(__x._M_start), _M_finish(__x._M_finish),
                	  _M_end_of_storage(__x._M_end_of_storage)
                	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
                #endif
                
                	void
                	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
                	{
                	  _M_start = __x._M_start;
                	  _M_finish = __x._M_finish;
                	  _M_end_of_storage = __x._M_end_of_storage;
                	}
                
                	void
                	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
                	{
                	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
                	  // information used by TBAA.
                	  _Vector_impl_data __tmp;
                	  __tmp._M_copy_data(*this);
                	  _M_copy_data(__x);
                	  __x._M_copy_data(__tmp);
                	}
                      };
                
          16 ->       struct _Vector_impl
                	: public _Tp_alloc_type, public _Vector_impl_data
                      {
           8 -> 	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
                	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
                	: _Tp_alloc_type()
                	{ }
                
           1 -> 	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a)
                	{ }
                
                #if __cplusplus >= 201103L
                	// Not defaulted, to enforce noexcept(true) even when
                	// !is_nothrow_move_constructible<_Tp_alloc_type>.
           7 -> 	_Vector_impl(_Vector_impl&& __x) noexcept
                	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
                	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
                	{ }
                #endif
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                	template<typename = _Tp_alloc_type>
                	  struct _Asan
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    static void _S_shrink(_Vector_impl&, size_type) { }
                	    static void _S_on_dealloc(_Vector_impl&) { }
                
                	    typedef _Vector_impl& _Reinit;
                
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl&, size_type) { }
                	      void _M_grew(size_type) { }
                	    };
                	  };
                
                	// Enable ASan annotations for memory obtained from std::allocator.
                	template<typename _Up>
                	  struct _Asan<allocator<_Up> >
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to
                	    // mark end of valid region as __curr instead of __prev.
                	    static void
                	    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)
                	    {
                	      __sanitizer_annotate_contiguous_container(__impl._M_start,
                		  __impl._M_end_of_storage, __prev, __curr);
                	    }
                
                	    static void
                	    _S_grow(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }
                
                	    static void
                	    _S_shrink(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }
                
                	    static void
                	    _S_on_dealloc(_Vector_impl& __impl)
                	    {
                	      if (__impl._M_start)
                		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);
                	    }
                
                	    // Used on reallocation to tell ASan unused capacity is invalid.
                	    struct _Reinit
                	    {
                	      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)
                	      {
                		// Mark unused capacity as valid again before deallocating it.
                		_S_on_dealloc(_M_impl);
                	      }
                
                	      ~_Reinit()
                	      {
                		// Mark unused capacity as invalid after reallocation.
                		if (_M_impl._M_start)
                		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,
                			    _M_impl._M_finish);
                	      }
                
                	      _Vector_impl& _M_impl;
                
                #if __cplusplus >= 201103L
                	      _Reinit(const _Reinit&) = delete;
                	      _Reinit& operator=(const _Reinit&) = delete;
                #endif
                	    };
                
                	    // Tell ASan when unused capacity is initialized to be valid.
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl& __impl, size_type __n)
                	      : _M_impl(__impl), _M_n(__n)
                	      { _S_grow(_M_impl, __n); }
                
                	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }
                
                	      void _M_grew(size_type __n) { _M_n -= __n; }
                
                #if __cplusplus >= 201103L
                	      _Grow(const _Grow&) = delete;
                	      _Grow& operator=(const _Grow&) = delete;
                #endif
                	    private:
                	      _Vector_impl& _M_impl;
                	      size_type _M_n;
                	    };
                	  };
                
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT \
                  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \
                	__attribute__((__unused__)) __reinit_guard(this->_M_impl)
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \
                  typename _Base::_Vector_impl::template _Asan<>::_Grow \
                	__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \
                  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \
                  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)
                #else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
                #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                      };
                
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
          68 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Tp_alloc_type&
          50 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
           8 ->       _Vector_base() = default;
                #else
                      _Vector_base() { }
                #endif
                
           1 ->       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      // Kept for ABI compatibility.
                #if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                #endif
                
       ##### ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
           7 ->       _Vector_base(_Vector_base&&) = default;
                
                      // Kept for ABI compatibility.
                # if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                # endif
                
                      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
                      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
                      { }
                #endif
                
          16 ->       ~_Vector_base() _GLIBCXX_NOEXCEPT
                      {
                	_M_deallocate(_M_impl._M_start,
                		      _M_impl._M_end_of_storage - _M_impl._M_start);
                      }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
          26 ->       _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
                      }
                
                      void
          41 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    protected:
                      void
       ##### ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // Concept requirements.
                      typedef typename _Alloc::value_type		_Alloc_value_type;
                # if __cplusplus < 201103L
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                # endif
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                #endif
                
                #if __cplusplus >= 201103L
                      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
                	  "std::vector must have a non-const, non-volatile value_type");
                # ifdef __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
                	  "std::vector must have the same value_type as its allocator");
                # endif
                #endif
                
                      typedef _Vector_base<_Tp, _Alloc>			_Base;
                      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
                
                    public:
                      typedef _Tp					value_type;
                      typedef typename _Base::pointer			pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                      typedef size_t					size_type;
                      typedef ptrdiff_t					difference_type;
                      typedef _Alloc					allocator_type;
                
                    private:
                #if __cplusplus >= 201103L
                      static constexpr bool
          50 ->       _S_nothrow_relocate(true_type)
                      {
                	return noexcept(std::__relocate_a(std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<_Tp_alloc_type&>()));
                      }
                
                      static constexpr bool
                      _S_nothrow_relocate(false_type)
                      { return false; }
                
                      static constexpr bool
          50 ->       _S_use_relocate()
                      {
                	// Instantiating std::__relocate_a might cause an error outside the
                	// immediate context (in __relocate_object_a's noexcept-specifier),
                	// so only do it if we know the type can be move-inserted into *this.
                	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
                      }
                
                      static pointer
          50 ->       _S_do_relocate(pointer __first, pointer __last, pointer __result,
                		     _Tp_alloc_type& __alloc, true_type) noexcept
                      {
                	return std::__relocate_a(__first, __last, __result, __alloc);
                      }
                
                      static pointer
                      _S_do_relocate(pointer, pointer, pointer __result,
                		     _Tp_alloc_type&, false_type) noexcept
                      { return __result; }
                
                      static pointer
          50 ->       _S_relocate(pointer __first, pointer __last, pointer __result,
                		  _Tp_alloc_type& __alloc) noexcept
                      {
                	using __do_it = __bool_constant<_S_use_relocate()>;
                	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
                      }
                #endif // C++11
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
                #if __cplusplus >= 201103L
           8 ->       vector() = default;
                #else
                      vector() { }
                #endif
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x  will not be copied
                       *  (i.e. capacity() == size() in the new %vector).
                       *
                       *  The newly-created %vector uses a copy of the allocator object used
                       *  by @a __x (unless the allocator traits dictate a different object).
                       */
       ##### ->       vector(const vector& __x)
                      : _Base(__x.size(),
                	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *
                       *  The newly-created %vector contains the exact contents of the
                       *  moved instance.
                       *  The contents of the moved instance are a valid, but unspecified
                       *  %vector.
                       */
           7 ->       vector(vector&&) noexcept = default;
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                    private:
                      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
                      : _Base(__m, std::move(__rv))
                      { }
                
                      vector(vector&& __rv, const allocator_type& __m, false_type)
                      : _Base(__m)
                      {
                	if (__rv.get_allocator() == __m)
                	  this->_M_impl._M_swap_data(__rv._M_impl);
                	else if (!__rv.empty())
                	  {
                	    this->_M_create_storage(__rv.size());
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                    public:
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept( noexcept(
                	vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
                	       std::declval<typename _Alloc_traits::is_always_equal>())) )
                      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
                      { }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
           1 ->       vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #else
                      template<typename _InputIterator>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
          16 ->       ~vector() _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
                      }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x will not be copied.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  Afterwards @a __x is a valid, but unspecified %vector.
                       *
                       *  Whether the allocator is moved depends on the allocator traits.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	constexpr bool __move_storage =
                	  _Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal();
                	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{ _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
          25 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
       ##### ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
          25 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
       ##### ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
    33541232 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
          50 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _S_max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
     3098685 ->       operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
    62007357 ->       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      _Tp*
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      const _Tp*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
          21 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), __x);
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                #if __cplusplus > 201402L
                	reference
                #else
                	void
                #endif
                	emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                	iterator
                	emplace(const_iterator __position, _Args&&... __args)
                	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return _M_insert_rval(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      {
                	auto __offset = __position - cbegin();
                	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                			std::random_access_iterator_tag());
                	return begin() + __offset;
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                	insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                	void
                	insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       *
                       *  Whether the allocators are swapped depends on the allocator traits.
                       */
                      void
                      swap(vector& __x) _GLIBCXX_NOEXCEPT
                      {
                #if __cplusplus >= 201103L
                	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
                			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
                #endif
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                				  __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
           1 ->       clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                	pointer
                	_M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                	{
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                #if __cplusplus < 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                	{
                	  this->_M_impl._M_start = _M_allocate(_S_check_init_len(
                		static_cast<size_type>(__n), _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #endif
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_initialize(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag)
                	{
                	  __try {
                	    for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                	      push_back(*__first);
                #endif
                	  } __catch(...) {
                	    clear();
                	    __throw_exception_again;
                	  }
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                	void
           1 -> 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag)
                	{
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start
                	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
                					   _M_get_Tp_allocator());
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                	{ _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                	{ _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                	{
                	  _M_range_insert(__pos, __first, __last,
                			  std::__iterator_category(__first));
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                #if __cplusplus < 201103L
                      // Called by insert(p,x)
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                
                      void
                      _M_realloc_insert(iterator __position, const value_type& __x);
                #else
                      // A value_type object constructed with _Alloc_traits::construct()
                      // and destroyed with _Alloc_traits::destroy().
                      struct _Temporary_value
                      {
                	template<typename... _Args>
                	  explicit
                	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
                	  {
                	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
                				     std::forward<_Args>(__args)...);
                	  }
                
                	~_Temporary_value()
                	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
                
                	value_type&
                	_M_val() { return *_M_ptr(); }
                
                      private:
                	_Tp*
                	_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }
                
                	vector* _M_this;
                	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
                      };
                
                      // Called by insert(p,x) and other functions when insertion needs to
                      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
                      template<typename _Arg>
                	void
                	_M_insert_aux(iterator __position, _Arg&& __arg);
                
                      template<typename... _Args>
                	void
                	_M_realloc_insert(iterator __position, _Args&&... __args);
                
                      // Either move-construct at the end, or forward to _M_insert_aux.
                      iterator
                      _M_insert_rval(const_iterator __position, value_type&& __v);
                
                      // Try to emplace at the end, otherwise forward to _M_insert_aux.
                      template<typename... _Args>
                	iterator
                	_M_emplace_aux(const_iterator __position, _Args&&... __args);
                
                      // Emplacing an rvalue of the correct type can use _M_insert_rval.
                      iterator
                      _M_emplace_aux(const_iterator __position, value_type&& __v)
                      { return _M_insert_rval(__position, std::move(__v)); }
                #endif
                
                      // Called by _M_fill_insert, _M_insert_aux etc.
                      size_type
          25 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + (std::max)(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Called by constructors to check initial size.
                      static size_type
           1 ->       _S_check_init_len(size_type __n, const allocator_type& __a)
                      {
                	if (__n > _S_max_size(_Tp_alloc_type(__a)))
                	  __throw_length_error(
                	      __N("cannot create std::vector larger than max_size()"));
                	return __n;
                      }
                
                      static size_type
          51 ->       _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
                      {
                	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
                	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
                	// (even if std::allocator_traits::max_size says we can).
                	const size_t __diffmax
                	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
                	const size_t __allocmax = _Alloc_traits::max_size(__a);
                	return (std::min)(__diffmax, __allocmax);
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
           1 ->       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	if (size_type __n = this->_M_impl._M_finish - __pos)
                	  {
                	    std::_Destroy(__pos, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    this->_M_impl._M_finish = __pos;
                	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
                	  }
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__x._M_impl);
                	__tmp._M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                #if __cplusplus >= 201103L
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__to_address(__ptr); }
                #else
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	value_type*
                	_M_data_ptr(_Ptr __ptr)
                	{ return empty() ? (value_type*)0 : __ptr.operator->(); }
                
                      template<typename _Ptr>
                	const value_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? (const value_type*)0 : __ptr.operator->(); }
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _InputIterator, typename _ValT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_ValT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> vector<_ValT, _Allocator>;
                #endif
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // vector into a variant, but only if move assignment cannot throw.
                    template<typename _Tp, typename _Alloc>
                      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

     1058   62007357
      915   33541232
     1040    3098685
      273         68
     1773         51
      277         50
      428         50
      441         50
      450         50
      462         50

Execution Summary:

       40   Executable lines in this file
       40   Lines executed
   100.00   Percent of the file executed

 98647972   Total number of line executions
2466199.30   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                #include <bits/ptr_traits.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_array_constexpr 201803L
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::pointer		pointer;
                      typedef typename __traits_type::reference		reference;
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      // 1012. reverse_iterator default ctor should value initialize
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit _GLIBCXX17_CONSTEXPR
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      reverse_iterator& operator=(const reverse_iterator&) = default;
                #endif
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                	_GLIBCXX17_CONSTEXPR
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.base()) { }
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 1052. operator-> should also support smart pointers
                	_Iterator __tmp = current;
                	--__tmp;
                	return _S_to_pointer(__tmp);
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                
                    private:
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR _Tp*
                	_S_to_pointer(_Tp* __p)
                        { return __p; }
                
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR pointer
                	_S_to_pointer(_Tp __t)
                        { return __t.operator->(); }
                    };
                
                  ///@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward many operations to their underlying base()
                   *  iterators.  Others are implemented in terms of one another.
                   *
                  */
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                  ///@}
                
                #if __cplusplus < 201103L
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() - __x.base(); }
                #else
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 685. reverse_iterator/move_iterator difference has invalid signatures
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                    { return __y.base() - __x.base(); }
                #endif
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                #if __cplusplus >= 201103L
                  // Same as C++14 make_reverse_iterator but used in C++11 mode too.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    __make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                # if __cplusplus > 201103L
                #  define __cpp_lib_make_reverse_iterator 201402
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 2285. make_reverse_iterator
                  /// Generator function for reverse_iterator.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                # endif
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _Iterator>
                    auto
                    __niter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
                    { return __make_reverse_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<reverse_iterator<_Iterator> >
                      : __is_move_iterator<_Iterator>
                    { };
                
                  template<typename _Iterator>
                    auto
                    __miter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
                    { return __make_reverse_iterator(__miter_base(__it.base())); }
                #endif
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit
                      back_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit front_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                      typename _Container::iterator iter;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      insert_iterator(_Container& __x, typename _Container::iterator __i)
                      : container(std::__addressof(__x)), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @param __i  An iterator into the container.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, typename _Container::iterator __i)
                    { return insert_iterator<_Container>(__x, __i); }
                
                  /// @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  using std::iterator_traits;
                  using std::iterator;
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
                      : _M_current(_Iterator()) { }
                
                      explicit
          50 ->       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
                      : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      reference
       ##### ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_current; }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                
                      __normal_iterator&
       ##### ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator++(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      __normal_iterator&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	--_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator--(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return _M_current[__n]; }
                
                      __normal_iterator&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current += __n; return *this; }
                
                      __normal_iterator
                      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current + __n); }
                
                      __normal_iterator&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current -= __n; return *this; }
                
                      __normal_iterator
                      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current - __n); }
                
                      const _Iterator&
         100 ->       base() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                  // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
       ##### ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
          25 ->     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    _GLIBCXX_NOEXCEPT
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Iterator, typename _Container>
                    _Iterator
       ##### ->     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it.base(); }
                
                #if __cplusplus >= 201103L
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                      typedef typename __traits_type::reference		__base_ref;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2106. move_iterator wrapping iterators returning prvalues
                      typedef typename conditional<is_reference<__base_ref>::value,
                			 typename remove_reference<__base_ref>::type&&,
                			 __base_ref>::type		reference;
                
                      _GLIBCXX17_CONSTEXPR
                      move_iterator()
                      : _M_current() { }
                
                      explicit _GLIBCXX17_CONSTEXPR
       ##### ->       move_iterator(iterator_type __i)
                      : _M_current(__i) { }
                
                      template<typename _Iter>
                	_GLIBCXX17_CONSTEXPR
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i.base()) { }
                
                      _GLIBCXX17_CONSTEXPR iterator_type
       ##### ->       base() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR reference
       ##### ->       operator*() const
                      { return static_cast<reference>(*_M_current); }
                
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
       ##### ->       operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return std::move(_M_current[__n]); }
                    };
                
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why there are always 2 versions for most of the move_iterator
                  // operators.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
       ##### ->     operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
       ##### ->     operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(__i); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
                    __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // Overload for pointers that matches std::move_if_noexcept more closely,
                  // returning a constant iterator when we don't want to move.
                  template<typename _Tp, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
                			   const _Tp*, move_iterator<_Tp*>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
       ##### ->     __make_move_if_noexcept_iterator(_Tp* __i)
                    { return _ReturnType(__i); }
                
                  /// @} group iterators
                
                  template<typename _Iterator>
                    auto
                    __niter_base(move_iterator<_Iterator> __it)
                    -> decltype(make_move_iterator(__niter_base(__it.base())))
                    { return make_move_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<move_iterator<_Iterator> >
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<typename _Iterator>
                    auto
       ##### ->     __miter_base(move_iterator<_Iterator> __it)
                    -> decltype(__miter_base(__it.base()))
                    { return __miter_base(__it.base()); }
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #if __cpp_deduction_guides >= 201606
                  // These helper traits are used for deduction guides
                  // of associative containers.
                  template<typename _InputIterator>
                    using __iter_key_t = remove_const_t<
                    typename iterator_traits<_InputIterator>::value_type::first_type>;
                
                  template<typename _InputIterator>
                    using __iter_val_t =
                    typename iterator_traits<_InputIterator>::value_type::second_type;
                
                  template<typename _T1, typename _T2>
                    struct pair;
                
                  template<typename _InputIterator>
                    using __iter_to_alloc_t =
                    pair<add_const_t<__iter_key_t<_InputIterator>>,
                	 __iter_val_t<_InputIterator>>;
                
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #ifdef _GLIBCXX_DEBUG
                # include <debug/stl_iterator.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      868        100
      803         50
      986         25

Execution Summary:

       15   Executable lines in this file
       15   Lines executed
   100.00   Percent of the file executed

      175   Total number of line executions
    11.67   Average executions per line


*** File /usr/include/c++/9/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #define __cpp_lib_incomplete_container_elements 201505
                #if __cplusplus >= 201103L
                # define __cpp_lib_allocator_is_always_equal 201411
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                
                      template<typename _Up, typename... _Args>
                	void
                	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
                	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #endif
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator : public __allocator_base<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3035. std::allocator's constructors should be constexpr
                      _GLIBCXX20_CONSTEXPR
          16 ->       allocator() _GLIBCXX_NOTHROW { }
                
                      _GLIBCXX20_CONSTEXPR
          30 ->       allocator(const allocator& __a) _GLIBCXX_NOTHROW
                      : __allocator_base<_Tp>(__a) { }
                
                #if __cplusplus >= 201103L
                      // Avoid implicit deprecation.
                      allocator& operator=(const allocator&) = default;
                #endif
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
          21 -> 	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
                
          67 ->       ~allocator() _GLIBCXX_NOTHROW { }
                
                      friend bool
                      operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return true; }
                
                      friend bool
                      operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return false; }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return false; }
                
                  // Invalid allocator<cv T> partial specializations.
                  // allocator_traits::rebind_alloc can be used to form a valid allocator type.
                  template<typename _Tp>
                    class allocator<const _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<const volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) noexcept { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c) noexcept
                      {
                #if __cpp_exceptions
                	try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	catch(...)
                	  { return false; }
                #else
                	return false;
                #endif
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      152         67
      140         30
      150         21
      137         16

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

      134   Total number of line executions
    33.50   Average executions per line


*** File /usr/include/c++/9/bits/stl_bvector.h:
                // vector<bool> specialization -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1999
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_bvector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_BVECTOR_H
                #define _STL_BVECTOR_H 1
                
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #include <bits/functional_hash.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  typedef unsigned long _Bit_type;
                  enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };
                
                  struct _Bit_reference
                  {
                    _Bit_type * _M_p;
                    _Bit_type _M_mask;
                
     2711478 ->     _Bit_reference(_Bit_type * __x, _Bit_type __y)
                    : _M_p(__x), _M_mask(__y) { }
                
                    _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }
                
                #if __cplusplus >= 201103L
                    _Bit_reference(const _Bit_reference&) = default;
                #endif
                
     2711380 ->     operator bool() const _GLIBCXX_NOEXCEPT
                    { return !!(*_M_p & _M_mask); }
                
                    _Bit_reference&
          98 ->     operator=(bool __x) _GLIBCXX_NOEXCEPT
                    {
                      if (__x)
                	*_M_p |= _M_mask;
                      else
                	*_M_p &= ~_M_mask;
                      return *this;
                    }
                
                    _Bit_reference&
                    operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT
                    { return *this = bool(__x); }
                
                    bool
                    operator==(const _Bit_reference& __x) const
                    { return bool(*this) == bool(__x); }
                
                    bool
                    operator<(const _Bit_reference& __x) const
                    { return !bool(*this) && bool(__x); }
                
                    void
                    flip() _GLIBCXX_NOEXCEPT
                    { *_M_p ^= _M_mask; }
                  };
                
                #if __cplusplus >= 201103L
                  inline void
                  swap(_Bit_reference __x, _Bit_reference __y) noexcept
                  {
                    bool __tmp = __x;
                    __x = __y;
                    __y = __tmp;
                  }
                
                  inline void
                  swap(_Bit_reference __x, bool& __y) noexcept
                  {
                    bool __tmp = __x;
                    __x = __y;
                    __y = __tmp;
                  }
                
                  inline void
                  swap(bool& __x, _Bit_reference __y) noexcept
                  {
                    bool __tmp = __x;
                    __x = __y;
                    __y = __tmp;
                  }
                #endif
                
                  struct _Bit_iterator_base
                  : public std::iterator<std::random_access_iterator_tag, bool>
                  {
                    _Bit_type * _M_p;
                    unsigned int _M_offset;
                
    30622517 ->     _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
                    : _M_p(__x), _M_offset(__y) { }
                
                    void
         147 ->     _M_bump_up()
                    {
                      if (_M_offset++ == int(_S_word_bit) - 1)
                	{
                	  _M_offset = 0;
                	  ++_M_p;
                	}
                    }
                
                    void
                    _M_bump_down()
                    {
                      if (_M_offset-- == 0)
                	{
                	  _M_offset = int(_S_word_bit) - 1;
                	  --_M_p;
                	}
                    }
                
                    void
          14 ->     _M_incr(ptrdiff_t __i)
                    {
                      difference_type __n = __i + _M_offset;
                      _M_p += __n / int(_S_word_bit);
                      __n = __n % int(_S_word_bit);
                      if (__n < 0)
                	{
                	  __n += int(_S_word_bit);
                	  --_M_p;
                	}
                      _M_offset = static_cast<unsigned int>(__n);
                    }
                
                    bool
       ##### ->     operator==(const _Bit_iterator_base& __i) const
                    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }
                
                    bool
                    operator<(const _Bit_iterator_base& __i) const
                    {
                      return _M_p < __i._M_p
                	    || (_M_p == __i._M_p && _M_offset < __i._M_offset);
                    }
                
                    bool
       ##### ->     operator!=(const _Bit_iterator_base& __i) const
                    { return !(*this == __i); }
                
                    bool
                    operator>(const _Bit_iterator_base& __i) const
                    { return __i < *this; }
                
                    bool
                    operator<=(const _Bit_iterator_base& __i) const
                    { return !(__i < *this); }
                
                    bool
                    operator>=(const _Bit_iterator_base& __i) const
                    { return !(*this < __i); }
                  };
                
                  inline ptrdiff_t
                  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    13955558 ->   {
                    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
                	    + __x._M_offset - __y._M_offset);
                  }
                
                  struct _Bit_iterator : public _Bit_iterator_base
                  {
                    typedef _Bit_reference  reference;
                    typedef _Bit_reference* pointer;
                    typedef _Bit_iterator   iterator;
                
          42 ->     _Bit_iterator() : _Bit_iterator_base(0, 0) { }
                
          21 ->     _Bit_iterator(_Bit_type * __x, unsigned int __y)
                    : _Bit_iterator_base(__x, __y) { }
                
                    iterator
                    _M_const_cast() const
                    { return *this; }
                
                    reference
          98 ->     operator*() const
                    { return reference(_M_p, 1UL << _M_offset); }
                
                    iterator&
          98 ->     operator++()
                    {
                      _M_bump_up();
                      return *this;
                    }
                
                    iterator
                    operator++(int)
                    {
                      iterator __tmp = *this;
                      _M_bump_up();
                      return __tmp;
                    }
                
                    iterator&
                    operator--()
                    {
                      _M_bump_down();
                      return *this;
                    }
                
                    iterator
                    operator--(int)
                    {
                      iterator __tmp = *this;
                      _M_bump_down();
                      return __tmp;
                    }
                
                    iterator&
          14 ->     operator+=(difference_type __i)
                    {
                      _M_incr(__i);
                      return *this;
                    }
                
                    iterator&
                    operator-=(difference_type __i)
                    {
                      *this += -__i;
                      return *this;
                    }
                
                    iterator
          14 ->     operator+(difference_type __i) const
                    {
                      iterator __tmp = *this;
                      return __tmp += __i;
                    }
                
                    iterator
                    operator-(difference_type __i) const
                    {
                      iterator __tmp = *this;
                      return __tmp -= __i;
                    }
                
                    reference
                    operator[](difference_type __i) const
                    { return *(*this + __i); }
                  };
                
                  inline _Bit_iterator
                  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
                  { return __x + __n; }
                
                  struct _Bit_const_iterator : public _Bit_iterator_base
                  {
                    typedef bool                 reference;
                    typedef bool                 const_reference;
                    typedef const bool*          pointer;
                    typedef _Bit_const_iterator  const_iterator;
                
                    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
                
    16666896 ->     _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
                    : _Bit_iterator_base(__x, __y) { }
                
    13955558 ->     _Bit_const_iterator(const _Bit_iterator& __x)
                    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }
                
                    _Bit_iterator
                    _M_const_cast() const
                    { return _Bit_iterator(_M_p, _M_offset); }
                
                    const_reference
     2711380 ->     operator*() const
                    { return _Bit_reference(_M_p, 1UL << _M_offset); }
                
                    const_iterator&
          49 ->     operator++()
                    {
                      _M_bump_up();
                      return *this;
                    }
                
                    const_iterator
                    operator++(int)
                    {
                      const_iterator __tmp = *this;
                      _M_bump_up();
                      return __tmp;
                    }
                
                    const_iterator&
                    operator--()
                    {
                      _M_bump_down();
                      return *this;
                    }
                
                    const_iterator
                    operator--(int)
                    {
                      const_iterator __tmp = *this;
                      _M_bump_down();
                      return __tmp;
                    }
                
                    const_iterator&
                    operator+=(difference_type __i)
                    {
                      _M_incr(__i);
                      return *this;
                    }
                
                    const_iterator&
                    operator-=(difference_type __i)
                    {
                      *this += -__i;
                      return *this;
                    }
                
                    const_iterator
                    operator+(difference_type __i) const
                    {
                      const_iterator __tmp = *this;
                      return __tmp += __i;
                    }
                
                    const_iterator
                    operator-(difference_type __i) const
                    {
                      const_iterator __tmp = *this;
                      return __tmp -= __i;
                    }
                
                    const_reference
                    operator[](difference_type __i) const
                    { return *(*this + __i); }
                  };
                
                  inline _Bit_const_iterator
                  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
                  { return __x + __n; }
                
                  inline void
                  __fill_bvector(_Bit_type * __v,
                		 unsigned int __first, unsigned int __last, bool __x)
                  {
                    const _Bit_type __fmask = ~0ul << __first;
                    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
                    const _Bit_type __mask = __fmask & __lmask;
                
                    if (__x)
                      *__v |= __mask;
                    else
                      *__v &= ~__mask;
                  }
                
                  inline void
                  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
                  {
                    if (__first._M_p != __last._M_p)
                      {
                	_Bit_type* __first_p = __first._M_p;
                	if (__first._M_offset != 0)
                	  __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);
                
                	__builtin_memset(__first_p, __x ? ~0 : 0,
                			 (__last._M_p - __first_p) * sizeof(_Bit_type));
                
                	if (__last._M_offset != 0)
                	  __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
                      }
                    else if (__first._M_offset != __last._M_offset)
                      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
                  }
                
                  template<typename _Alloc>
                    struct _Bvector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Bit_type>::other _Bit_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
                	_Bit_alloc_traits;
                      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;
                
                      struct _Bvector_impl_data
                      {
                	_Bit_iterator 	_M_start;
                	_Bit_iterator 	_M_finish;
                	_Bit_pointer 	_M_end_of_storage;
                
          14 -> 	_Bvector_impl_data() _GLIBCXX_NOEXCEPT
                	: _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
                	: _M_start(__x._M_start), _M_finish(__x._M_finish)
                	, _M_end_of_storage(__x._M_end_of_storage)
                	{ __x._M_reset(); }
                
                	void
                	_M_move_data(_Bvector_impl_data&& __x) noexcept
                	{
                	  this->_M_start = __x._M_start;
                	  this->_M_finish = __x._M_finish;
                	  this->_M_end_of_storage = __x._M_end_of_storage;
                	  __x._M_reset();
                	}
                #endif
                
                	void
          14 -> 	_M_reset() _GLIBCXX_NOEXCEPT
                	{
                	  _M_start = _M_finish = _Bit_iterator();
                	  _M_end_of_storage = _Bit_pointer();
                	}
                      };
                
          14 ->       struct _Bvector_impl
                	: public _Bit_alloc_type, public _Bvector_impl_data
                	{
                	public:
                	  _Bvector_impl() _GLIBCXX_NOEXCEPT_IF(
                		is_nothrow_default_constructible<_Bit_alloc_type>::value)
                	  : _Bit_alloc_type()
                	  { }
                
          14 -> 	  _Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT
                	  : _Bit_alloc_type(__a)
                	  { }
                
                #if __cplusplus >= 201103L
                	_Bvector_impl(_Bvector_impl&&) = default;
                #endif
                
                	_Bit_type*
          14 -> 	_M_end_addr() const _GLIBCXX_NOEXCEPT
                	{
                	  if (this->_M_end_of_storage)
                	    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
                	  return 0;
                	}
                      };
                
                    public:
                      typedef _Alloc allocator_type;
                
                      _Bit_alloc_type&
                      _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Bit_alloc_type&
           7 ->       _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Bit_allocator()); }
                
                #if __cplusplus >= 201103L
                      _Bvector_base() = default;
                #else
                      _Bvector_base() { }
                #endif
                
          14 ->       _Bvector_base(const allocator_type& __a)
                      : _M_impl(__a) { }
                
                #if __cplusplus >= 201103L
                      _Bvector_base(_Bvector_base&&) = default;
                #endif
                
          14 ->       ~_Bvector_base()
                      { this->_M_deallocate(); }
                
                    protected:
                      _Bvector_impl _M_impl;
                
                      _Bit_pointer
          14 ->       _M_allocate(size_t __n)
                      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }
                
                      void
          14 ->       _M_deallocate()
                      {
                	if (_M_impl._M_start._M_p)
                	  {
                	    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
                	    _Bit_alloc_traits::deallocate(_M_impl,
                					  _M_impl._M_end_of_storage - __n,
                					  __n);
                	    _M_impl._M_reset();
                	  }
                      }
                
                #if __cplusplus >= 201103L
                      void
                      _M_move_data(_Bvector_base&& __x) noexcept
                      { _M_impl._M_move_data(std::move(__x._M_impl)); }
                #endif
                
                      static size_t
          28 ->       _S_nword(size_t __n)
                      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
                    };
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                // Declare a partial specialization of vector<T, Alloc>.
                #include <bits/stl_vector.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /**
                   *  @brief  A specialization of vector for booleans which offers fixed time
                   *  access to individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Alloc  Allocator type.
                   *
                   *  Note that vector<bool> does not actually meet the requirements for being
                   *  a container.  This is because the reference and pointer types are not
                   *  really references and pointers to bool.  See DR96 for details.  @see
                   *  vector for function documentation.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Alloc>
                    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
                    {
                      typedef _Bvector_base<_Alloc>			_Base;
                      typedef typename _Base::_Bit_pointer		_Bit_pointer;
                      typedef typename _Base::_Bit_alloc_traits		_Bit_alloc_traits;
                
                #if __cplusplus >= 201103L
                      friend struct std::hash<vector>;
                #endif
                
                    public:
                      typedef bool					value_type;
                      typedef size_t					size_type;
                      typedef ptrdiff_t					difference_type;
                      typedef _Bit_reference				reference;
                      typedef bool					const_reference;
                      typedef _Bit_reference*				pointer;
                      typedef const bool*				const_pointer;
                      typedef _Bit_iterator				iterator;
                      typedef _Bit_const_iterator			const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                      typedef _Alloc					allocator_type;
                
                      allocator_type
                      get_allocator() const
                      { return _Base::get_allocator(); }
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_S_nword;
                      using _Base::_M_get_Bit_allocator;
                
                    public:
                #if __cplusplus >= 201103L
                      vector() = default;
                #else
                      vector() { }
                #endif
                
                      explicit
                      vector(const allocator_type& __a)
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : vector(__n, false, __a)
                      { }
                
                      vector(size_type __n, const bool& __value,
                	     const allocator_type& __a = allocator_type())
                #else
                      explicit
                      vector(size_type __n, const bool& __value = bool(),
                	     const allocator_type& __a = allocator_type())
                #endif
                      : _Base(__a)
                      {
                	_M_initialize(__n);
                	_M_initialize_value(__value);
                      }
                
           7 ->       vector(const vector& __x)
                      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
                      {
                	_M_initialize(__x.size());
                	_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
                      }
                
                #if __cplusplus >= 201103L
                      vector(vector&&) = default;
                
                      vector(vector&& __x, const allocator_type& __a)
                      noexcept(_Bit_alloc_traits::_S_always_equal())
                      : _Base(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_move_data(std::move(__x));
                	else
                	  {
                	    _M_initialize(__x.size());
                	    _M_copy_aligned(__x.begin(), __x.end(), begin());
                	    __x.clear();
                	  }
                      }
                
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__a)
                      {
                	_M_initialize(__x.size());
                	_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
                      }
                
           7 ->       vector(initializer_list<bool> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_initialize_range(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{ _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
          14 ->       ~vector() _GLIBCXX_NOEXCEPT { }
                
                      vector&
                      operator=(const vector& __x)
                      {
                	if (&__x == this)
                	  return *this;
                #if __cplusplus >= 201103L
                	if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
                	  {
                	    if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
                	      {
                		this->_M_deallocate();
                		std::__alloc_on_copy(_M_get_Bit_allocator(),
                				     __x._M_get_Bit_allocator());
                		_M_initialize(__x.size());
                	      }
                	    else
                	      std::__alloc_on_copy(_M_get_Bit_allocator(),
                				   __x._M_get_Bit_allocator());
                	  }
                #endif
                	if (__x.size() > capacity())
                	  {
                	    this->_M_deallocate();
                	    _M_initialize(__x.size());
                	  }
                	this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
                						  begin());
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      vector&
                      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
                      {
                	if (_Bit_alloc_traits::_S_propagate_on_move_assign()
                	    || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
                	  {
                	    this->_M_deallocate();
                	    this->_M_move_data(std::move(__x));
                	    std::__alloc_on_move(_M_get_Bit_allocator(),
                				 __x._M_get_Bit_allocator());
                	  }
                	else
                	  {
                	    if (__x.size() > capacity())
                	      {
                		this->_M_deallocate();
                		_M_initialize(__x.size());
                	      }
                	    this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
                						      begin());
                	    __x.clear();
                	  }
                	return *this;
                      }
                
                      vector&
                      operator=(initializer_list<bool> __l)
                      {
                	this->assign (__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      // assign(), a generalized assignment member function.  Two
                      // versions: one that takes a count, and one that takes a range.
                      // The range version is a member template, so we dispatch on whether
                      // or not the type is an integer.
                      void
                      assign(size_type __n, const bool& __x)
                      { _M_fill_assign(__n, __x); }
                
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                #else
                      template<typename _InputIterator>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      void
                      assign(initializer_list<bool> __l)
                      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }
                #endif
                
                      iterator
       ##### ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start._M_p, 0); }
                
                      const_iterator
    13955558 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start._M_p, 0); }
                
                      iterator
       ##### ->       end() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish; }
                
                      const_iterator
    13955558 ->       end() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish; }
                
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start._M_p, 0); }
                
                      const_iterator
                      cend() const noexcept
                      { return this->_M_impl._M_finish; }
                
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      size_type
    13955551 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(end() - begin()); }
                
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      {
                	const size_type __isize =
                	  __gnu_cxx::__numeric_traits<difference_type>::__max
                	  - int(_S_word_bit) + 1;
                	const size_type __asize
                	  = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
                	return (__asize <= __isize / int(_S_word_bit)
                		? __asize * int(_S_word_bit) : __isize);
                      }
                
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
                			 - begin()); }
                
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      reference
                      operator[](size_type __n)
                      {
                	return *iterator(this->_M_impl._M_start._M_p
                			 + __n / int(_S_word_bit), __n % int(_S_word_bit));
                      }
                
                      const_reference
     2711331 ->       operator[](size_type __n) const
                      {
                	return *const_iterator(this->_M_impl._M_start._M_p
                			     + __n / int(_S_word_bit), __n % int(_S_word_bit));
                      }
                
                    protected:
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector<bool>::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      reference
                      at(size_type __n)
                      { _M_range_check(__n); return (*this)[__n]; }
                
                      const_reference
                      at(size_type __n) const
                      { _M_range_check(__n); return (*this)[__n]; }
                
                      void
                      reserve(size_type __n)
                      {
                	if (__n > max_size())
                	  __throw_length_error(__N("vector::reserve"));
                	if (capacity() < __n)
                	  _M_reallocate(__n);
                      }
                
                      reference
                      front()
                      { return *begin(); }
                
                      const_reference
                      front() const
                      { return *begin(); }
                
                      reference
                      back()
                      { return *(end() - 1); }
                
                      const_reference
                      back() const
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // N.B. DR 464 says nothing about vector<bool> but we need something
                      // here due to the way we are implementing DR 464 in the debug-mode
                      // vector class.
                      void
                      data() _GLIBCXX_NOEXCEPT { }
                
                      void
                      push_back(bool __x)
                      {
                	if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	  *this->_M_impl._M_finish++ = __x;
                	else
                	  _M_insert_aux(end(), __x);
                      }
                
                      void
                      swap(vector& __x) _GLIBCXX_NOEXCEPT
                      {
                	std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                	std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                	std::swap(this->_M_impl._M_end_of_storage,
                		  __x._M_impl._M_end_of_storage);
                	_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
                				      __x._M_get_Bit_allocator());
                      }
                
                      // [23.2.5]/1, third-to-last entry in synopsis listing
                      static void
                      swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT
                      {
                	bool __tmp = __x;
                	__x = __y;
                	__y = __tmp;
                      }
                
                      iterator
                #if __cplusplus >= 201103L
                      insert(const_iterator __position, const bool& __x = bool())
                #else
                      insert(iterator __position, const bool& __x = bool())
                #endif
                      {
                	const difference_type __n = __position - begin();
                	if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
                	    && __position == end())
                	  *this->_M_impl._M_finish++ = __x;
                	else
                	  _M_insert_aux(__position._M_const_cast(), __x);
                	return begin() + __n;
                      }
                
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                	insert(const_iterator __position,
                	       _InputIterator __first, _InputIterator __last)
                	{
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(__position._M_const_cast(),
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      template<typename _InputIterator>
                	void
                	insert(iterator __position,
                	       _InputIterator __first, _InputIterator __last)
                	{
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      iterator
                      insert(const_iterator __position, size_type __n, const bool& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(__position._M_const_cast(), __n, __x);
                	return begin() + __offset;
                      }
                #else
                      void
                      insert(iterator __position, size_type __n, const bool& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      iterator
                      insert(const_iterator __p, initializer_list<bool> __l)
                      { return this->insert(__p, __l.begin(), __l.end()); }
                #endif
                
                      void
                      pop_back()
                      { --this->_M_impl._M_finish; }
                
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                #else
                      erase(iterator __position)
                #endif
                      { return _M_erase(__position._M_const_cast()); }
                
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                #else
                      erase(iterator __first, iterator __last)
                #endif
                      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
                
                      void
                      resize(size_type __new_size, bool __x = bool())
                      {
                	if (__new_size < size())
                	  _M_erase_at_end(begin() + difference_type(__new_size));
                	else
                	  insert(end(), __new_size - size(), __x);
                      }
                
                #if __cplusplus >= 201103L
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      void
                      flip() _GLIBCXX_NOEXCEPT
                      {
                	_Bit_type * const __end = this->_M_impl._M_end_addr();
                	for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
                	  *__p = ~*__p;
                      }
                
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(begin()); }
                
                #if __cplusplus >= 201103L
                      template<typename... _Args>
                #if __cplusplus > 201402L
                	reference
                #else
                	void
                #endif
                	emplace_back(_Args&&... __args)
                	{
                	  push_back(bool(__args...));
                #if __cplusplus > 201402L
                	  return back();
                #endif
                	}
                
                      template<typename... _Args>
                	iterator
                	emplace(const_iterator __pos, _Args&&... __args)
                	{ return insert(__pos, bool(__args...)); }
                #endif
                
                    protected:
                      // Precondition: __first._M_offset == 0 && __result._M_offset == 0.
                      iterator
           7 ->       _M_copy_aligned(const_iterator __first, const_iterator __last,
                		      iterator __result)
                      {
                	_Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
                	return std::copy(const_iterator(__last._M_p, 0), __last,
                			 iterator(__q, 0));
                      }
                
                      void
          14 ->       _M_initialize(size_type __n)
                      {
                	if (__n)
                	  {
                	    _Bit_pointer __q = this->_M_allocate(__n);
                	    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                	    this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
                	  }
                	else
                	  {
                	    this->_M_impl._M_end_of_storage = _Bit_pointer();
                	    this->_M_impl._M_start = iterator(0, 0);
                	  }
                	this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
                
                      }
                
                      void
                      _M_initialize_value(bool __x)
                      {
                	if (_Bit_type* __p = this->_M_impl._M_start._M_p)
                	  __builtin_memset(__p, __x ? ~0 : 0,
                			   (this->_M_impl._M_end_addr() - __p)
                			   * sizeof(_Bit_type));
                      }
                
                      void
                      _M_reallocate(size_type __n);
                
                #if __cplusplus >= 201103L
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      // Check whether it's an integral type.  If so, it's not an iterator.
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
                	{
                	  _M_initialize(static_cast<size_type>(__n));
                	  _M_initialize_value(__x);
                	}
                
                      template<typename _InputIterator>
                	void
                	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                	{ _M_initialize_range(__first, __last,
                			      std::__iterator_category(__first)); }
                
                      template<typename _InputIterator>
                	void
                	_M_initialize_range(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag)
                	{
                	  for (; __first != __last; ++__first)
                	    push_back(*__first);
                	}
                
                      template<typename _ForwardIterator>
                	void
           7 -> 	_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag)
                	{
                	  const size_type __n = std::distance(__first, __last);
                	  _M_initialize(__n);
                	  std::copy(__first, __last, this->_M_impl._M_start);
                	}
                
                #if __cplusplus < 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                	{ _M_fill_assign(__n, __val); }
                
                      template<class _InputIterator>
                	void
                	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                #endif
                
                      void
                      _M_fill_assign(size_t __n, bool __x)
                      {
                	if (__n > size())
                	  {
                	    _M_initialize_value(__x);
                	    insert(end(), __n - size(), __x);
                	  }
                	else
                	  {
                	    _M_erase_at_end(begin() + __n);
                	    _M_initialize_value(__x);
                	  }
                      }
                
                      template<typename _InputIterator>
                	void
                	_M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag)
                	{
                	  iterator __cur = begin();
                	  for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
                	    *__cur = *__first;
                	  if (__first == __last)
                	    _M_erase_at_end(__cur);
                	  else
                	    insert(end(), __first, __last);
                	}
                
                      template<typename _ForwardIterator>
                	void
                	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag)
                	{
                	  const size_type __len = std::distance(__first, __last);
                	  if (__len < size())
                	    _M_erase_at_end(std::copy(__first, __last, begin()));
                	  else
                	    {
                	      _ForwardIterator __mid = __first;
                	      std::advance(__mid, size());
                	      std::copy(__first, __mid, begin());
                	      insert(end(), __mid, __last);
                	    }
                	}
                
                      // Check whether it's an integral type.  If so, it's not an iterator.
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                			   __true_type)
                	{ _M_fill_insert(__pos, __n, __x); }
                
                      template<typename _InputIterator>
                	void
                	_M_insert_dispatch(iterator __pos,
                			   _InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_insert_range(__pos, __first, __last,
                			  std::__iterator_category(__first)); }
                
                      void
                      _M_fill_insert(iterator __position, size_type __n, bool __x);
                
                      template<typename _InputIterator>
                	void
                	_M_insert_range(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag)
                	{
                	  for (; __first != __last; ++__first)
                	    {
                	      __pos = insert(__pos, *__first);
                	      ++__pos;
                	    }
                	}
                
                      template<typename _ForwardIterator>
                	void
                	_M_insert_range(iterator __position, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      void
                      _M_insert_aux(iterator __position, bool __x);
                
                      size_type
                      _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      void
                      _M_erase_at_end(iterator __pos)
                      { this->_M_impl._M_finish = __pos; }
                
                      iterator
                      _M_erase(iterator __pos);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                  };
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                  /// std::hash specialization for vector<bool>.
                  template<typename _Alloc>
                    struct hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>
                    : public __hash_base<size_t, _GLIBCXX_STD_C::vector<bool, _Alloc>>
                    {
                      size_t
                      operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>&) const noexcept;
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                }// namespace std
                
                #endif // C++11
                
                #endif


Top 10 Lines:

     Line      Count

      148   30622517
      315   16666896
      215   13955558
      318   13955558
      815   13955558
      823   13955558
      861   13955551
       77    2711478
       86    2711380
      326    2711380

Execution Summary:

       42   Executable lines in this file
       42   Lines executed
   100.00   Percent of the file executed

127913577   Total number of line executions
3045561.36   Average executions per line


*** File /usr/include/c++/9/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap
                #include <bits/predefined_ops.h>
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  typedef typename iterator_traits<_ForwardIterator1>::value_type
                	    _ValueType1;
                	  _ValueType1 __tmp = *__a;
                	  *__a = *__b;
                	  *__b = __tmp;
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  swap(*__a, *__b);
                	}
                    };
                #endif
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline void
                    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
          51 ->     min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
          25 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the __normal_iterator wrapper. See copy, fill, ...
                  template<typename _Iterator>
                    inline _Iterator
         213 ->     __niter_base(_Iterator __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it; }
                
                  // Reverse the __niter_base transformation to get a
                  // __normal_iterator back again (this assumes that __normal_iterator
                  // is only used to wrap random access iterators, like pointers).
                  template<typename _From, typename _To>
                    inline _From
                    __niter_wrap(_From __from, _To __res)
                    { return __from + (__res - std::__niter_base(__from)); }
                
                  // No need to wrap, iterator already has the right type.
                  template<typename _Iterator>
                    inline _Iterator
          21 ->     __niter_wrap(const _Iterator&, _Iterator __res)
                    { return __res; }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	static _OI
          14 -> 	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	static _Tp*
           7 -> 	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
          21 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                      const bool __simple = (__is_trivially_copyable(_ValueTypeI)
                			     && __is_pointer<_II>::__value
                			     && __is_pointer<_OI>::__value
                			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                
                      return std::__copy_move<_IsMove, __simple,
                			      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
          21 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_a<_IsMove>(std::__niter_base(__first),
                					    std::__niter_base(__last),
                					    std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
          21 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a2<__is_move_iterator<_II>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
                    move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a2<true>(std::__miter_base(__first),
                				       std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool, bool, typename>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	static _Tp*
                	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
                    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                      const bool __simple = (__is_trivially_copyable(_ValueType1)
                			     && __is_pointer<_BI1>::__value
                			     && __is_pointer<_BI2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__copy_move_backward<_IsMove, __simple,
                				       _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
                    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_backward_a<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
                    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
                    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
                						std::__miter_base(__last),
                						__result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                 	     const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                      if (const size_t __len = __last - __first)
                	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
                    }
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
                		    __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
                    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
                    {
                      std::__fill_a(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @ wmemset.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 865. More algorithms that throw away information
                  */
                  template<typename _OI, typename _Size, typename _Tp>
                    inline _OI
                    fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                      __glibcxx_requires_can_increment(__first, __n);
                
                      return std::__niter_wrap(__first,
                		std::__fill_n_a(std::__niter_base(__first), __n, __value));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                	static bool
                	equal(_II1 __first1, _II1 __last1, _II2 __first2)
                	{
                	  for (; __first1 != __last1; ++__first1, (void) ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                	static bool
                	equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                	{
                	  if (const size_t __len = (__last1 - __first1))
                	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
                	  return true;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                			     && __is_pointer<_II1>::__value
                			     && __is_pointer<_II2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                	static _II1
                	__newlast1(_II1, _II1 __last1, _II2, _II2)
                	{ return __last1; }
                
                      template<typename _II>
                	static bool
                	__cnd2(_II __first, _II __last)
                	{ return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                	static _RAI1
                	__newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                	{
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                	static bool
                	__cnd2(_RAI, _RAI)
                	{ return true; }
                    };
                
                  template<typename _II1, typename _II2, typename _Compare>
                    bool
                    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2,
                				   _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, (void)++__first2)
                	{
                	  if (__comp(__first1, __first2))
                	    return true;
                	  if (__comp(__first2, __first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                	static bool __lc(_II1, _II1, _II2, _II2);
                    };
                
                  template<bool _BoolType>
                    template<typename _II1, typename _II2>
                      bool
                      __lexicographical_compare<_BoolType>::
                      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                      {
                	return std::__lexicographical_compare_impl(__first1, __last1,
                						   __first2, __last2,
                					__gnu_cxx::__ops::__iter_less_iter());
                      }
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                	static bool
                	__lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  if (const size_t __len = std::min(__len1, __len2))
                	    if (int __result = __builtin_memcmp(__first1, __first2, __len))
                	      return __result < 0;
                	  return __len1 < __len2;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
                	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
                	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value);
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _ForwardIterator
                    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val());
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_can_increment_range(__first1, __last1, __first2);
                
                      return std::__equal_aux(std::__niter_base(__first1),
                			      std::__niter_base(__last1),
                			      std::__niter_base(__first2));
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                #if __cplusplus >= 201103L
                  // 4-iterator version of std::equal<It1, It2> for use in C++11.
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                
                  // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.
                  template<typename _II1, typename _II2, typename _BinaryPredicate>
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
                				       __binary_pred);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                #endif // C++11
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_robust_nonmodifying_seq_ops 201304
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,
                				      __binary_pred);
                    }
                #endif // C++14
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
                						std::__niter_base(__last1),
                						std::__niter_base(__first2),
                						std::__niter_base(__last2));
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_impl
                	(__first1, __last1, __first2, __last2,
                	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                #if __cplusplus > 201103L
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __first2 != __last2
                	     && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_ALGO
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested.
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      280        213
      198         51
      222         25
      295         21
      393         21
      438         21
      465         21
      337         14
      375          7

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

      394   Total number of line executions
    43.78   Average executions per line


*** File /work/classwork/hw5/schedwork.cpp:
                #ifndef RECCHECK
                #include <set>
                #include <iostream>
                #include <fstream>
                #include <string>
                #include <vector>
                #include <map>
                #include <algorithm>
                // add or remove necessary headers as you please
                #include <ext/concurrence.h>
                #endif
                
                #include "schedwork.h"
                
                
                
                using namespace std;
                
                // a constant that can be used to indicate an INVALID 
                // worker ID if that is useful to your implementation.
                // Feel free to not use or delete.
                static const Worker_T INVALID_ID = (unsigned int)-1;
                
                
                // Add prototypes for any helper functions here
                
     1549332 -> void init_vec_sizet(const size_t size, size_t*& vec, size_t i = 0) {
                    if (i >= size) return;
                    if (size == 7) {
                        delete [] vec;
                        vec = new size_t[8]{0, 0, 0, 0, 0, 0, 0};
                    }
                    vec[i] = 0u;
                    return init_vec_sizet(size, vec, i + 1);
                }
     6208884 -> void init_vec_workert(const size_t size, Worker_T*& vec, size_t i = 0) {
                    if (i == size) return;
                    if (size == 7) {
                        delete [] vec;
                        vec = new Worker_T[8]{INVALID_ID, INVALID_ID, INVALID_ID, INVALID_ID, INVALID_ID, INVALID_ID, INVALID_ID};
                        return;
                    }
                    vec[i] = INVALID_ID;
                    return init_vec_workert(size, vec, i + 1);
                }
                
                
                // Add your implementation of schedule() and other helper functions here
                
                bool schedule(
                    const AvailabilityMatrix& avail,
                    const size_t dailyNeed,
                    const size_t maxShifts,
                    DailySchedule& sched
           1 ->     ) {
                    if(avail.size() == 0U){
                        return false;
                    }
                    sched.clear();
                    // Add your code below
                
                    createAndFillSchedule(avail, dailyNeed, sched);
                
                    return scheduleInteral(avail, dailyNeed, maxShifts, sched);
                
                }
                
                bool scheduleInteral(
                    const AvailabilityMatrix& avail,
                    const size_t dailyNeed,
                    const size_t maxShifts,
                    DailySchedule& sched,
                    size_t current_day,
                    size_t current_shift
           1 ->     ) {
                
                    if (current_shift >= dailyNeed) {
                        current_day += 1;
                        current_shift = 0;
                
                        if (current_day >= avail.size()) {
                            return schedueSatisfiesConstraints(avail, dailyNeed, maxShifts, sched, current_day, current_shift);
                        }
                    }
                
                    const std::vector<bool>& currentDayAvailability = avail[current_day];
                
                
                    for (Worker_T currentWorkerID = 0; currentWorkerID < currentDayAvailability.size(); currentWorkerID++) {
                
                        if (!currentDayAvailability[currentWorkerID]) continue;
                
                        sched[current_day][current_shift] = currentWorkerID;
                
                        if (!schedueSatisfiesConstraints(avail, dailyNeed, maxShifts, sched, current_day, current_shift)) continue;
                
                        if (scheduleInteral(avail, dailyNeed, maxShifts, sched, current_day, current_shift + 1)) return true;
                
                    }
                
                    return false;
                }
                
                
                bool schedueSatisfiesConstraints(
                    const AvailabilityMatrix& avail,
                    const size_t dailyNeed,
                    const size_t maxShifts,
                    const DailySchedule& sched,
                    const size_t to_day,
                    const size_t to_shift
     1549332 ->     ) {
                    size_t* worker_shifts = new size_t[avail[0].size()];
                    init_vec_sizet(avail[0].size(), worker_shifts);
                
                    Worker_T* workersPerDay = new Worker_T[avail[0].size()];
                    init_vec_workert(avail[0].size(), workersPerDay);
                
                    bool success = scheduleConformsToMaxShifts(avail, dailyNeed, maxShifts, sched, to_day, to_shift, workersPerDay, worker_shifts, 0, 0);
                
                    delete [] worker_shifts;
                    delete [] workersPerDay;
                
                    return success;
                
                
                }
                
                bool scheduleConformsToMaxShifts(
                    const AvailabilityMatrix& avail,
                    const size_t dailyNeed,
                    const size_t maxShifts,
                    const DailySchedule& sched,
                    const size_t to_day,
                    const size_t to_shift,
                    Worker_T*& workersPerDay,
                    size_t*& worker_shifts,
                    size_t current_day,
                    size_t current_shift
     1549332 ->     ){
                
                
                
                    //finished iterating
                    if (current_day >= sched.size()) return true;
                
                    Worker_T current_worker = sched[current_day][current_shift];
                    if (workersPerDay[current_worker] != INVALID_ID) return false;
                    workersPerDay[current_worker] = 0;
                
                    if (current_worker != INVALID_ID) {
                        worker_shifts[current_worker]++;
                    }else {
                        //check for invalid ids
                        return false;
                    }
                
                    if (worker_shifts[current_worker] > maxShifts) return false;
                
                    current_shift += 1;
                
                    //iterated through the section we need to and found no errors
                    if (current_shift >= to_shift && current_day >= to_day) return true;
                
                    //advance day
                    if (current_shift >= sched[current_day].size()) {
                        current_day += 1;
                        current_shift = 0;
                        init_vec_workert(avail[0].size(), workersPerDay);
                    }
                
                    return scheduleConformsToMaxShifts(
                        avail,
                        dailyNeed,
                        maxShifts,
                        sched,
                        to_day,
                        to_shift,
                        workersPerDay,
                        worker_shifts,
                        current_day,
                        current_shift
                        );
                }
                
                void createAndFillSchedule(
                    const AvailabilityMatrix& avail,
                    const size_t daily_need,
                    DailySchedule& sched,
                    size_t current_day,
                    size_t current_shift
           1 -> ) {
                
                    if (current_shift >= daily_need) {
                        current_day += 1;
                        current_shift = 0;
                
                        if (current_day >= avail.size()) return;
                
                        sched.emplace_back();
                    }else if (current_day == 0 && current_shift == 0) {
                        sched.emplace_back();
                    }
                
                    sched[current_day].push_back(INVALID_ID);
                
                    createAndFillSchedule(avail, daily_need, sched, current_day, current_shift + 1);
                
           2 -> }
                
                
                


Top 10 Lines:

     Line      Count

       36    6208884
       27    1549332
      112    1549332
      140    1549332
      209          2
       55          1
       75          1
      192          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

 10856885   Total number of line executions
1357110.62   Average executions per line


*** File /work/classwork/hw5/schedwork-driver.cpp:
                // main() program to test your schedule function.
                // Feel free to modify this program in any way you need for testing.
                // It will not be graded. 
                #include <set>
                #include <iostream>
                #include <fstream>
                #include <string>
                #include <vector>
                #include <map>
                #include <algorithm>
                #include "schedwork.h"
                
                using namespace std;
                
                void printSchedule(const DailySchedule& sched);
                
                int main()
       ##### -> {
                    // Replace the matrix below with your test case
                    AvailabilityMatrix avail = { 
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1},
                        {1, 1, 1, 0, 0, 0, 1}
                    };
                    DailySchedule sched;
                    bool solutionFound = schedule(avail, 3, 3, sched);
                    if(solutionFound)
                    {
                        printSchedule(sched);
                    }
                    else
                    {
                        cout << "No solution found!" << endl;
                    }
                    return 0;
                }
                
                void printAvailability(const AvailabilityMatrix& avail)
       ##### -> {
                
                    cout << "worker: ";
                    for (int i = 0; i < avail.size(); i++) {
                        cout << i << " ";
                    }
                    cout << endl;
                
                    int day = 0;
                    for(vector<bool> d : avail)
                    {
                        cout << "Day " << day << ": ";
                        for(bool aval : d)
                        {
                            cout << boolalpha << aval << " ";
                        }
                        cout << endl;
                        day++;
                    }
                }
                
                void printSchedule(const DailySchedule& sched)
       ##### -> {
                    int day = 0;
                    for(auto s : sched)
                    {
                        cout << "Day " << day << ": ";
                        for(auto nurse : s)
                        {
                            cout << nurse << " ";
                        }
                        cout << endl;
                        day++;
                    }
           2 -> }


Top 10 Lines:

     Line      Count

       77          2

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.50   Average executions per line
